{"ast":null,"code":"//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/\nvar PostgrestError = class extends Error {\n  /**\n  * @example\n  * ```ts\n  * import PostgrestError from '@supabase/postgrest-js'\n  *\n  * throw new PostgrestError({\n  *   message: 'Row level security prevented the request',\n  *   details: 'RLS denied the insert',\n  *   hint: 'Check your policies',\n  *   code: 'PGRST301',\n  * })\n  * ```\n  */\n  constructor(context) {\n    super(context.message);\n    this.name = \"PostgrestError\";\n    this.details = context.details;\n    this.hint = context.hint;\n    this.code = context.code;\n  }\n};\n\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n  /**\n  * Creates a builder configured for a specific PostgREST request.\n  *\n  * @example\n  * ```ts\n  * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n  *\n  * const builder = new PostgrestQueryBuilder(\n  *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n  *   { headers: new Headers({ apikey: 'public-anon-key' }) }\n  * )\n  * ```\n  */\n  constructor(builder) {\n    var _builder$shouldThrowO, _builder$isMaybeSingl;\n    this.shouldThrowOnError = false;\n    this.method = builder.method;\n    this.url = builder.url;\n    this.headers = new Headers(builder.headers);\n    this.schema = builder.schema;\n    this.body = builder.body;\n    this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n    this.signal = builder.signal;\n    this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n    if (builder.fetch) this.fetch = builder.fetch;else this.fetch = fetch;\n  }\n  /**\n  * If there's an error with the query, throwOnError will reject the promise by\n  * throwing the error instead of returning it as part of a successful response.\n  *\n  * {@link https://github.com/supabase/supabase-js/issues/92}\n  */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\n  * Set an HTTP header for the request.\n  */\n  setHeader(name, value) {\n    this.headers = new Headers(this.headers);\n    this.headers.set(name, value);\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    var _this = this;\n    if (this.schema === void 0) {} else if ([\"GET\", \"HEAD\"].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);else this.headers.set(\"Content-Profile\", this.schema);\n    if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n    const _fetch = this.fetch;\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then(async res$1 => {\n      let error = null;\n      let data = null;\n      let count = null;\n      let status = res$1.status;\n      let statusText = res$1.statusText;\n      if (res$1.ok) {\n        var _this$headers$get2, _res$headers$get;\n        if (_this.method !== \"HEAD\") {\n          var _this$headers$get;\n          const body = await res$1.text();\n          if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;else data = JSON.parse(body);\n        }\n        const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n        if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n        if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n          error = {\n            code: \"PGRST116\",\n            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n            hint: null,\n            message: \"JSON object requested, multiple (or no) rows returned\"\n          };\n          data = null;\n          count = null;\n          status = 406;\n          statusText = \"Not Acceptable\";\n        } else if (data.length === 1) data = data[0];else data = null;\n      } else {\n        var _error$details;\n        const body = await res$1.text();\n        try {\n          error = JSON.parse(body);\n          if (Array.isArray(error) && res$1.status === 404) {\n            data = [];\n            error = null;\n            status = 200;\n            statusText = \"OK\";\n          }\n        } catch (_unused) {\n          if (res$1.status === 404 && body === \"\") {\n            status = 204;\n            statusText = \"No Content\";\n          } else error = {\n            message: body\n          };\n        }\n        if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n          error = null;\n          status = 200;\n          statusText = \"OK\";\n        }\n        if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n      }\n      return {\n        error,\n        data,\n        count,\n        status,\n        statusText\n      };\n    });\n    if (!this.shouldThrowOnError) res = res.catch(fetchError => {\n      var _fetchError$name2;\n      let errorDetails = \"\";\n      const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n      if (cause) {\n        var _cause$message, _cause$code, _fetchError$name, _cause$name;\n        const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n        const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n        errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n        errorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n        if (causeCode) errorDetails += ` (${causeCode})`;\n        if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n      } else {\n        var _fetchError$stack;\n        errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n      }\n      return {\n        error: {\n          message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n          details: errorDetails,\n          hint: \"\",\n          code: \"\"\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: \"\"\n      };\n    });\n    return res.then(onfulfilled, onrejected);\n  }\n  /**\n  * Override the type of the returned `data`.\n  *\n  * @typeParam NewResult - The new result type to override with\n  * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n  */\n  returns() {\n    /* istanbul ignore next */\n    return this;\n  }\n  /**\n  * Override the type of the returned `data` field in the response.\n  *\n  * @typeParam NewResult - The new type to cast the response data to\n  * @typeParam Options - Optional type configuration (defaults to { merge: true })\n  * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n  * @example\n  * ```typescript\n  * // Merge with existing types (default behavior)\n  * const query = supabase\n  *   .from('users')\n  *   .select()\n  *   .overrideTypes<{ custom_field: string }>()\n  *\n  * // Replace existing types completely\n  * const replaceQuery = supabase\n  *   .from('users')\n  *   .select()\n  *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n  * ```\n  * @returns A PostgrestBuilder instance with the new type\n  */\n  overrideTypes() {\n    return this;\n  }\n};\n\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n  /**\n  * Perform a SELECT on the query result.\n  *\n  * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n  * return modified rows. By calling this method, modified rows are returned in\n  * `data`.\n  *\n  * @param columns - The columns to retrieve, separated by commas\n  */\n  select(columns) {\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map(c => {\n      if (/\\s/.test(c) && !quoted) return \"\";\n      if (c === \"\\\"\") quoted = !quoted;\n      return c;\n    }).join(\"\");\n    this.url.searchParams.set(\"select\", cleanedColumns);\n    this.headers.append(\"Prefer\", \"return=representation\");\n    return this;\n  }\n  /**\n  * Order the query result by `column`.\n  *\n  * You can call this method multiple times to order by multiple columns.\n  *\n  * You can order referenced tables, but it only affects the ordering of the\n  * parent table if you use `!inner` in the query.\n  *\n  * @param column - The column to order by\n  * @param options - Named parameters\n  * @param options.ascending - If `true`, the result will be in ascending order\n  * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n  * `null`s appear last.\n  * @param options.referencedTable - Set this to order a referenced table by\n  * its columns\n  * @param options.foreignTable - Deprecated, use `options.referencedTable`\n  * instead\n  */\n  order(column, {\n    ascending = true,\n    nullsFirst,\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = referencedTable ? `${referencedTable}.order` : \"order\";\n    const existingOrder = this.url.searchParams.get(key);\n    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n    return this;\n  }\n  /**\n  * Limit the query result by `count`.\n  *\n  * @param count - The maximum number of rows to return\n  * @param options - Named parameters\n  * @param options.referencedTable - Set this to limit rows of referenced\n  * tables instead of the parent table\n  * @param options.foreignTable - Deprecated, use `options.referencedTable`\n  * instead\n  */\n  limit(count, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n    this.url.searchParams.set(key, `${count}`);\n    return this;\n  }\n  /**\n  * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n  * Only records within this range are returned.\n  * This respects the query order and if there is no order clause the range could behave unexpectedly.\n  * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n  * and fourth rows of the query.\n  *\n  * @param from - The starting index from which to limit the result\n  * @param to - The last index to which to limit the result\n  * @param options - Named parameters\n  * @param options.referencedTable - Set this to limit rows of referenced\n  * tables instead of the parent table\n  * @param options.foreignTable - Deprecated, use `options.referencedTable`\n  * instead\n  */\n  range(from, to, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n    const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n    this.url.searchParams.set(keyOffset, `${from}`);\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n    return this;\n  }\n  /**\n  * Set the AbortSignal for the fetch request.\n  *\n  * @param signal - The AbortSignal to use for the fetch request\n  */\n  abortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  /**\n  * Return `data` as a single object instead of an array of objects.\n  *\n  * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n  * returns an error.\n  */\n  single() {\n    this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n    return this;\n  }\n  /**\n  * Return `data` as a single object instead of an array of objects.\n  *\n  * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n  * this returns an error.\n  */\n  maybeSingle() {\n    if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n    this.isMaybeSingle = true;\n    return this;\n  }\n  /**\n  * Return `data` as a string in CSV format.\n  */\n  csv() {\n    this.headers.set(\"Accept\", \"text/csv\");\n    return this;\n  }\n  /**\n  * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n  */\n  geojson() {\n    this.headers.set(\"Accept\", \"application/geo+json\");\n    return this;\n  }\n  /**\n  * Return `data` as the EXPLAIN plan for the query.\n  *\n  * You need to enable the\n  * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n  * setting before using this method.\n  *\n  * @param options - Named parameters\n  *\n  * @param options.analyze - If `true`, the query will be executed and the\n  * actual run time will be returned\n  *\n  * @param options.verbose - If `true`, the query identifier will be returned\n  * and `data` will include the output columns of the query\n  *\n  * @param options.settings - If `true`, include information on configuration\n  * parameters that affect query planning\n  *\n  * @param options.buffers - If `true`, include information on buffer usage\n  *\n  * @param options.wal - If `true`, include information on WAL record generation\n  *\n  * @param options.format - The format of the output, can be `\"text\"` (default)\n  * or `\"json\"`\n  */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = \"text\"\n  } = {}) {\n    var _this$headers$get;\n    const options = [analyze ? \"analyze\" : null, verbose ? \"verbose\" : null, settings ? \"settings\" : null, buffers ? \"buffers\" : null, wal ? \"wal\" : null].filter(Boolean).join(\"|\");\n    const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n    this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n    if (format === \"json\") return this;else return this;\n  }\n  /**\n  * Rollback the query.\n  *\n  * `data` will still be returned, but the query is not committed.\n  */\n  rollback() {\n    this.headers.append(\"Prefer\", \"tx=rollback\");\n    return this;\n  }\n  /**\n  * Override the type of the returned `data`.\n  *\n  * @typeParam NewResult - The new result type to override with\n  * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n  */\n  returns() {\n    return this;\n  }\n  /**\n  * Set the maximum number of rows that can be affected by the query.\n  * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n  *\n  * @param value - The maximum number of rows that can be affected\n  */\n  maxAffected(value) {\n    this.headers.append(\"Prefer\", \"handling=strict\");\n    this.headers.append(\"Prefer\", `max-affected=${value}`);\n    return this;\n  }\n};\n\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n  /**\n  * Match only rows where `column` is equal to `value`.\n  *\n  * To check if the value of `column` is NULL, you should use `.is()` instead.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  eq(column, value) {\n    this.url.searchParams.append(column, `eq.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is not equal to `value`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  neq(column, value) {\n    this.url.searchParams.append(column, `neq.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is greater than `value`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  gt(column, value) {\n    this.url.searchParams.append(column, `gt.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is greater than or equal to `value`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  gte(column, value) {\n    this.url.searchParams.append(column, `gte.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is less than `value`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  lt(column, value) {\n    this.url.searchParams.append(column, `lt.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is less than or equal to `value`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  lte(column, value) {\n    this.url.searchParams.append(column, `lte.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches `pattern` case-sensitively.\n  *\n  * @param column - The column to filter on\n  * @param pattern - The pattern to match with\n  */\n  like(column, pattern) {\n    this.url.searchParams.append(column, `like.${pattern}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches all of `patterns` case-sensitively.\n  *\n  * @param column - The column to filter on\n  * @param patterns - The patterns to match with\n  */\n  likeAllOf(column, patterns) {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches any of `patterns` case-sensitively.\n  *\n  * @param column - The column to filter on\n  * @param patterns - The patterns to match with\n  */\n  likeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches `pattern` case-insensitively.\n  *\n  * @param column - The column to filter on\n  * @param pattern - The pattern to match with\n  */\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, `ilike.${pattern}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches all of `patterns` case-insensitively.\n  *\n  * @param column - The column to filter on\n  * @param patterns - The patterns to match with\n  */\n  ilikeAllOf(column, patterns) {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches any of `patterns` case-insensitively.\n  *\n  * @param column - The column to filter on\n  * @param patterns - The patterns to match with\n  */\n  ilikeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches the PostgreSQL regex `pattern`\n  * case-sensitively (using the `~` operator).\n  *\n  * @param column - The column to filter on\n  * @param pattern - The PostgreSQL regular expression pattern to match with\n  */\n  regexMatch(column, pattern) {\n    this.url.searchParams.append(column, `match.${pattern}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` matches the PostgreSQL regex `pattern`\n  * case-insensitively (using the `~*` operator).\n  *\n  * @param column - The column to filter on\n  * @param pattern - The PostgreSQL regular expression pattern to match with\n  */\n  regexIMatch(column, pattern) {\n    this.url.searchParams.append(column, `imatch.${pattern}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` IS `value`.\n  *\n  * For non-boolean columns, this is only relevant for checking if the value of\n  * `column` is NULL by setting `value` to `null`.\n  *\n  * For boolean columns, you can also set `value` to `true` or `false` and it\n  * will behave the same way as `.eq()`.\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  is(column, value) {\n    this.url.searchParams.append(column, `is.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` IS DISTINCT FROM `value`.\n  *\n  * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n  * are considered equal (not distinct), and comparing `NULL` with any non-NULL\n  * value returns true (distinct).\n  *\n  * @param column - The column to filter on\n  * @param value - The value to filter with\n  */\n  isDistinct(column, value) {\n    this.url.searchParams.append(column, `isdistinct.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is included in the `values` array.\n  *\n  * @param column - The column to filter on\n  * @param values - The values array to filter with\n  */\n  in(column, values) {\n    const cleanedValues = Array.from(new Set(values)).map(s => {\n      if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;else return `${s}`;\n    }).join(\",\");\n    this.url.searchParams.append(column, `in.(${cleanedValues})`);\n    return this;\n  }\n  /**\n  * Match only rows where `column` is NOT included in the `values` array.\n  *\n  * @param column - The column to filter on\n  * @param values - The values array to filter with\n  */\n  notIn(column, values) {\n    const cleanedValues = Array.from(new Set(values)).map(s => {\n      if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;else return `${s}`;\n    }).join(\",\");\n    this.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n    return this;\n  }\n  /**\n  * Only relevant for jsonb, array, and range columns. Match only rows where\n  * `column` contains every element appearing in `value`.\n  *\n  * @param column - The jsonb, array, or range column to filter on\n  * @param value - The jsonb, array, or range value to filter with\n  */\n  contains(column, value) {\n    if (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n    return this;\n  }\n  /**\n  * Only relevant for jsonb, array, and range columns. Match only rows where\n  * every element appearing in `column` is contained by `value`.\n  *\n  * @param column - The jsonb, array, or range column to filter on\n  * @param value - The jsonb, array, or range value to filter with\n  */\n  containedBy(column, value) {\n    if (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n    return this;\n  }\n  /**\n  * Only relevant for range columns. Match only rows where every element in\n  * `column` is greater than any element in `range`.\n  *\n  * @param column - The range column to filter on\n  * @param range - The range to filter with\n  */\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, `sr.${range}`);\n    return this;\n  }\n  /**\n  * Only relevant for range columns. Match only rows where every element in\n  * `column` is either contained in `range` or greater than any element in\n  * `range`.\n  *\n  * @param column - The range column to filter on\n  * @param range - The range to filter with\n  */\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, `nxl.${range}`);\n    return this;\n  }\n  /**\n  * Only relevant for range columns. Match only rows where every element in\n  * `column` is less than any element in `range`.\n  *\n  * @param column - The range column to filter on\n  * @param range - The range to filter with\n  */\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, `sl.${range}`);\n    return this;\n  }\n  /**\n  * Only relevant for range columns. Match only rows where every element in\n  * `column` is either contained in `range` or less than any element in\n  * `range`.\n  *\n  * @param column - The range column to filter on\n  * @param range - The range to filter with\n  */\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, `nxr.${range}`);\n    return this;\n  }\n  /**\n  * Only relevant for range columns. Match only rows where `column` is\n  * mutually exclusive to `range` and there can be no element between the two\n  * ranges.\n  *\n  * @param column - The range column to filter on\n  * @param range - The range to filter with\n  */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, `adj.${range}`);\n    return this;\n  }\n  /**\n  * Only relevant for array and range columns. Match only rows where\n  * `column` and `value` have an element in common.\n  *\n  * @param column - The array or range column to filter on\n  * @param value - The array or range value to filter with\n  */\n  overlaps(column, value) {\n    if (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);else this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n    return this;\n  }\n  /**\n  * Only relevant for text and tsvector columns. Match only rows where\n  * `column` matches the query string in `query`.\n  *\n  * @param column - The text or tsvector column to filter on\n  * @param query - The query text to match with\n  * @param options - Named parameters\n  * @param options.config - The text search configuration to use\n  * @param options.type - Change how the `query` text is interpreted\n  */\n  textSearch(column, query, {\n    config,\n    type\n  } = {}) {\n    let typePart = \"\";\n    if (type === \"plain\") typePart = \"pl\";else if (type === \"phrase\") typePart = \"ph\";else if (type === \"websearch\") typePart = \"w\";\n    const configPart = config === void 0 ? \"\" : `(${config})`;\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  /**\n  * Match only rows where each column in `query` keys is equal to its\n  * associated value. Shorthand for multiple `.eq()`s.\n  *\n  * @param query - The object to filter with, with column names as keys mapped\n  * to their filter values\n  */\n  match(query) {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`);\n    });\n    return this;\n  }\n  /**\n  * Match only rows which doesn't satisfy the filter.\n  *\n  * Unlike most filters, `opearator` and `value` are used as-is and need to\n  * follow [PostgREST\n  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n  * to make sure they are properly sanitized.\n  *\n  * @param column - The column to filter on\n  * @param operator - The operator to be negated to filter with, following\n  * PostgREST syntax\n  * @param value - The value to filter with, following PostgREST syntax\n  */\n  not(column, operator, value) {\n    this.url.searchParams.append(column, `not.${operator}.${value}`);\n    return this;\n  }\n  /**\n  * Match only rows which satisfy at least one of the filters.\n  *\n  * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n  * to make sure it's properly sanitized.\n  *\n  * It's currently not possible to do an `.or()` filter across multiple tables.\n  *\n  * @param filters - The filters to use, following PostgREST syntax\n  * @param options - Named parameters\n  * @param options.referencedTable - Set this to filter on referenced tables\n  * instead of the parent table\n  * @param options.foreignTable - Deprecated, use `referencedTable` instead\n  */\n  or(filters, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = referencedTable ? `${referencedTable}.or` : \"or\";\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  /**\n  * Match only rows which satisfy the filter. This is an escape hatch - you\n  * should use the specific filter methods wherever possible.\n  *\n  * Unlike most filters, `opearator` and `value` are used as-is and need to\n  * follow [PostgREST\n  * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n  * to make sure they are properly sanitized.\n  *\n  * @param column - The column to filter on\n  * @param operator - The operator to filter with, following PostgREST syntax\n  * @param value - The value to filter with, following PostgREST syntax\n  */\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, `${operator}.${value}`);\n    return this;\n  }\n};\n\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n  /**\n  * Creates a query builder scoped to a Postgres table or view.\n  *\n  * @example\n  * ```ts\n  * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n  *\n  * const query = new PostgrestQueryBuilder(\n  *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n  *   { headers: { apikey: 'public-anon-key' } }\n  * )\n  * ```\n  */\n  constructor(url, {\n    headers = {},\n    schema,\n    fetch: fetch$1\n  }) {\n    this.url = url;\n    this.headers = new Headers(headers);\n    this.schema = schema;\n    this.fetch = fetch$1;\n  }\n  /**\n  * Clone URL and headers to prevent shared state between operations.\n  */\n  cloneRequestState() {\n    return {\n      url: new URL(this.url.toString()),\n      headers: new Headers(this.headers)\n    };\n  }\n  /**\n  * Perform a SELECT query on the table or view.\n  *\n  * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n  *\n  * @param options - Named parameters\n  *\n  * @param options.head - When set to `true`, `data` will not be returned.\n  * Useful if you only need the count.\n  *\n  * @param options.count - Count algorithm to use to count rows in the table or view.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  */\n  select(columns, options) {\n    const {\n      head = false,\n      count\n    } = options !== null && options !== void 0 ? options : {};\n    const method = head ? \"HEAD\" : \"GET\";\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map(c => {\n      if (/\\s/.test(c) && !quoted) return \"\";\n      if (c === \"\\\"\") quoted = !quoted;\n      return c;\n    }).join(\"\");\n    const {\n      url,\n      headers\n    } = this.cloneRequestState();\n    url.searchParams.set(\"select\", cleanedColumns);\n    if (count) headers.append(\"Prefer\", `count=${count}`);\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: this.fetch\n    });\n  }\n  /**\n  * Perform an INSERT into the table or view.\n  *\n  * By default, inserted rows are not returned. To return it, chain the call\n  * with `.select()`.\n  *\n  * @param values - The values to insert. Pass an object to insert a single row\n  * or an array to insert multiple rows.\n  *\n  * @param options - Named parameters\n  *\n  * @param options.count - Count algorithm to use to count inserted rows.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  *\n  * @param options.defaultToNull - Make missing fields default to `null`.\n  * Otherwise, use the default value for the column. Only applies for bulk\n  * inserts.\n  */\n  insert(values, {\n    count,\n    defaultToNull = true\n  } = {}) {\n    var _this$fetch;\n    const method = \"POST\";\n    const {\n      url,\n      headers\n    } = this.cloneRequestState();\n    if (count) headers.append(\"Prefer\", `count=${count}`);\n    if (!defaultToNull) headers.append(\"Prefer\", `missing=default`);\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n      }\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n    });\n  }\n  /**\n  * Perform an UPSERT on the table or view. Depending on the column(s) passed\n  * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n  * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n  * exist, or if it does exist, perform an alternative action depending on\n  * `ignoreDuplicates`.\n  *\n  * By default, upserted rows are not returned. To return it, chain the call\n  * with `.select()`.\n  *\n  * @param values - The values to upsert with. Pass an object to upsert a\n  * single row or an array to upsert multiple rows.\n  *\n  * @param options - Named parameters\n  *\n  * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n  * duplicate rows are determined. Two rows are duplicates if all the\n  * `onConflict` columns are equal.\n  *\n  * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n  * `false`, duplicate rows are merged with existing rows.\n  *\n  * @param options.count - Count algorithm to use to count upserted rows.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  *\n  * @param options.defaultToNull - Make missing fields default to `null`.\n  * Otherwise, use the default value for the column. This only applies when\n  * inserting new rows, not when merging with existing rows under\n  * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n  *\n  * @example Upsert a single row using a unique key\n  * ```ts\n  * // Upserting a single row, overwriting based on the 'username' unique column\n  * const { data, error } = await supabase\n  *   .from('users')\n  *   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n  *\n  * // Example response:\n  * // {\n  * //   data: [\n  * //     { id: 4, message: 'bar', username: 'supabot' }\n  * //   ],\n  * //   error: null\n  * // }\n  * ```\n  *\n  * @example Upsert with conflict resolution and exact row counting\n  * ```ts\n  * // Upserting and returning exact count\n  * const { data, error, count } = await supabase\n  *   .from('users')\n  *   .upsert(\n  *     {\n  *       id: 3,\n  *       message: 'foo',\n  *       username: 'supabot'\n  *     },\n  *     {\n  *       onConflict: 'username',\n  *       count: 'exact'\n  *     }\n  *   )\n  *\n  * // Example response:\n  * // {\n  * //   data: [\n  * //     {\n  * //       id: 42,\n  * //       handle: \"saoirse\",\n  * //       display_name: \"Saoirse\"\n  * //     }\n  * //   ],\n  * //   count: 1,\n  * //   error: null\n  * // }\n  * ```\n  */\n  upsert(values, {\n    onConflict,\n    ignoreDuplicates = false,\n    count,\n    defaultToNull = true\n  } = {}) {\n    var _this$fetch2;\n    const method = \"POST\";\n    const {\n      url,\n      headers\n    } = this.cloneRequestState();\n    headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n    if (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n    if (count) headers.append(\"Prefer\", `count=${count}`);\n    if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n      }\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch\n    });\n  }\n  /**\n  * Perform an UPDATE on the table or view.\n  *\n  * By default, updated rows are not returned. To return it, chain the call\n  * with `.select()` after filters.\n  *\n  * @param values - The values to update with\n  *\n  * @param options - Named parameters\n  *\n  * @param options.count - Count algorithm to use to count updated rows.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  */\n  update(values, {\n    count\n  } = {}) {\n    var _this$fetch3;\n    const method = \"PATCH\";\n    const {\n      url,\n      headers\n    } = this.cloneRequestState();\n    if (count) headers.append(\"Prefer\", `count=${count}`);\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch\n    });\n  }\n  /**\n  * Perform a DELETE on the table or view.\n  *\n  * By default, deleted rows are not returned. To return it, chain the call\n  * with `.select()` after filters.\n  *\n  * @param options - Named parameters\n  *\n  * @param options.count - Count algorithm to use to count deleted rows.\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  */\n  delete({\n    count\n  } = {}) {\n    var _this$fetch4;\n    const method = \"DELETE\";\n    const {\n      url,\n      headers\n    } = this.cloneRequestState();\n    if (count) headers.append(\"Prefer\", `count=${count}`);\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch\n    });\n  }\n};\n\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/\nvar PostgrestClient = class PostgrestClient {\n  /**\n  * Creates a PostgREST client.\n  *\n  * @param url - URL of the PostgREST endpoint\n  * @param options - Named parameters\n  * @param options.headers - Custom headers\n  * @param options.schema - Postgres schema to switch to\n  * @param options.fetch - Custom fetch\n  * @example\n  * ```ts\n  * import PostgrestClient from '@supabase/postgrest-js'\n  *\n  * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n  *   headers: { apikey: 'public-anon-key' },\n  *   schema: 'public',\n  * })\n  * ```\n  */\n  constructor(url, {\n    headers = {},\n    schema,\n    fetch: fetch$1\n  } = {}) {\n    this.url = url;\n    this.headers = new Headers(headers);\n    this.schemaName = schema;\n    this.fetch = fetch$1;\n  }\n  /**\n  * Perform a query on a table or a view.\n  *\n  * @param relation - The table or view name to query\n  */\n  from(relation) {\n    if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n    return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch\n    });\n  }\n  /**\n  * Select a schema to query or perform an function (rpc) call.\n  *\n  * The schema needs to be on the list of exposed schemas inside Supabase.\n  *\n  * @param schema - The schema to query\n  */\n  schema(schema) {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch\n    });\n  }\n  /**\n  * Perform a function call.\n  *\n  * @param fn - The function name to call\n  * @param args - The arguments to pass to the function call\n  * @param options - Named parameters\n  * @param options.head - When set to `true`, `data` will not be returned.\n  * Useful if you only need the count.\n  * @param options.get - When set to `true`, the function will be called with\n  * read-only access mode.\n  * @param options.count - Count algorithm to use to count rows returned by the\n  * function. Only applicable for [set-returning\n  * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n  *\n  * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n  * hood.\n  *\n  * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n  * statistics under the hood.\n  *\n  * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n  * numbers.\n  *\n  * @example\n  * ```ts\n  * // For cross-schema functions where type inference fails, use overrideTypes:\n  * const { data } = await supabase\n  *   .schema('schema_b')\n  *   .rpc('function_a', {})\n  *   .overrideTypes<{ id: string; user_id: string }[]>()\n  * ```\n  */\n  rpc(fn, args = {}, {\n    head = false,\n    get = false,\n    count\n  } = {}) {\n    var _this$fetch;\n    let method;\n    const url = new URL(`${this.url}/rpc/${fn}`);\n    let body;\n    const _isObject = v => v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n    const _hasObjectArg = head && Object.values(args).some(_isObject);\n    if (_hasObjectArg) {\n      method = \"POST\";\n      body = args;\n    } else if (head || get) {\n      method = head ? \"HEAD\" : \"GET\";\n      Object.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`]).forEach(([name, value]) => {\n        url.searchParams.append(name, value);\n      });\n    } else {\n      method = \"POST\";\n      body = args;\n    }\n    const headers = new Headers(this.headers);\n    if (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");else if (count) headers.set(\"Prefer\", `count=${count}`);\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n    });\n  }\n};\n\n//#endregion\n//#region src/index.ts\nvar src_default = {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError\n};\n\n//#endregion\nexport { PostgrestBuilder, PostgrestClient, PostgrestError, PostgrestFilterBuilder, PostgrestQueryBuilder, PostgrestTransformBuilder, src_default as default };","map":{"version":3,"names":["PostgrestError","Error","constructor","context","message","name","details","hint","code","PostgrestBuilder","builder","shouldThrowOnError","method","url","headers","Headers","schema","body","_builder$shouldThrowO","signal","isMaybeSingle","_builder$isMaybeSingl","fetch","throwOnError","setHeader","value","set","then","onfulfilled","onrejected","includes","_fetch","res","toString","JSON","stringify","res$1","error","data","count","status","statusText","ok","_this","text","get","_this$headers$get","parse","countHeader","_this$headers$get2","match","contentRange","_res$headers$get","split","length","parseInt","Array","isArray","_error$details","catch","fetchError","errorDetails","cause","causeMessage","_cause$message","causeCode","_cause$code","_fetchError$name","_cause$name","stack","_fetchError$stack","_fetchError$name2","returns","overrideTypes","PostgrestTransformBuilder","select","columns","quoted","cleanedColumns","map","c","test","join","searchParams","append","order","column","ascending","nullsFirst","foreignTable","referencedTable","key","existingOrder","limit","range","from","to","keyOffset","keyLimit","abortSignal","single","maybeSingle","csv","geojson","explain","analyze","verbose","settings","buffers","wal","format","options","filter","Boolean","forMediatype","rollback","maxAffected","PostgrestReservedCharsRegexp","RegExp","PostgrestFilterBuilder","eq","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","regexMatch","regexIMatch","is","isDistinct","in","values","cleanedValues","Set","s","notIn","contains","containedBy","rangeGt","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","typePart","configPart","Object","entries","forEach","not","operator","or","filters","PostgrestQueryBuilder","fetch$1","cloneRequestState","URL","head","insert","defaultToNull","reduce","acc","x","concat","keys","uniqueColumns","_this$fetch","upsert","onConflict","ignoreDuplicates","_this$fetch2","update","_this$fetch3","delete","_this$fetch4","PostgrestClient","schemaName","relation","trim","rpc","fn","args","_isObject","v","some","_hasObjectArg","_","src_default"],"sources":["/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestError.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestBuilder.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestTransformBuilder.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestFilterBuilder.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestQueryBuilder.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/PostgrestClient.ts","/home/steve/amala/client/node_modules/@supabase/postgrest-js/src/index.ts"],"sourcesContent":["/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport default class PostgrestError extends Error {\n  details: string\n  hint: string\n  code: string\n\n  /**\n   * @example\n   * ```ts\n   * import PostgrestError from '@supabase/postgrest-js'\n   *\n   * throw new PostgrestError({\n   *   message: 'Row level security prevented the request',\n   *   details: 'RLS denied the insert',\n   *   hint: 'Check your policies',\n   *   code: 'PGRST301',\n   * })\n   * ```\n   */\n  constructor(context: { message: string; details: string; hint: string; code: string }) {\n    super(context.message)\n    this.name = 'PostgrestError'\n    this.details = context.details\n    this.hint = context.hint\n    this.code = context.code\n  }\n}\n","import type {\n  PostgrestSingleResponse,\n  PostgrestResponseSuccess,\n  CheckMatchingArrayTypes,\n  MergePartialResult,\n  IsValidResultOverride,\n} from './types/types'\nimport { ClientServerOptions, Fetch } from './types/common/common'\nimport PostgrestError from './PostgrestError'\nimport { ContainsNull } from './select-query-parser/types'\n\nexport default abstract class PostgrestBuilder<\n  ClientOptions extends ClientServerOptions,\n  Result,\n  ThrowOnError extends boolean = false,\n> implements\n    PromiseLike<\n      ThrowOnError extends true ? PostgrestResponseSuccess<Result> : PostgrestSingleResponse<Result>\n    >\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Headers\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n\n  /**\n   * Creates a builder configured for a specific PostgREST request.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const builder = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: new Headers({ apikey: 'public-anon-key' }) }\n   * )\n   * ```\n   */\n  constructor(builder: {\n    method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n    url: URL\n    headers: HeadersInit\n    schema?: string\n    body?: unknown\n    shouldThrowOnError?: boolean\n    signal?: AbortSignal\n    fetch?: Fetch\n    isMaybeSingle?: boolean\n  }) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = new Headers(builder.headers)\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError ?? false\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle ?? false\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this & PostgrestBuilder<ClientOptions, Result, true> {\n    this.shouldThrowOnError = true\n    return this as this & PostgrestBuilder<ClientOptions, Result, true>\n  }\n\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name: string, value: string): this {\n    this.headers = new Headers(this.headers)\n    this.headers.set(name, value)\n    return this\n  }\n\n  then<\n    TResult1 = ThrowOnError extends true\n      ? PostgrestResponseSuccess<Result>\n      : PostgrestSingleResponse<Result>,\n    TResult2 = never,\n  >(\n    onfulfilled?:\n      | ((\n          value: ThrowOnError extends true\n            ? PostgrestResponseSuccess<Result>\n            : PostgrestSingleResponse<Result>\n        ) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers.set('Accept-Profile', this.schema)\n    } else {\n      this.headers.set('Content-Profile', this.schema)\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers.set('Content-Type', 'application/json')\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers.get('Accept') === 'text/csv') {\n            data = body\n          } else if (\n            this.headers.get('Accept') &&\n            this.headers.get('Accept')?.includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers.get('Prefer')?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError(error)\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => {\n        // Build detailed error information including cause if available\n        // Note: We don't populate code/hint for client-side network errors since those\n        // fields are meant for upstream service errors (PostgREST/PostgreSQL)\n        let errorDetails = ''\n\n        // Add cause information if available (e.g., DNS errors, network failures)\n        const cause = fetchError?.cause\n        if (cause) {\n          const causeMessage = cause?.message ?? ''\n          const causeCode = cause?.code ?? ''\n\n          errorDetails = `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`\n          errorDetails += `\\n\\nCaused by: ${cause?.name ?? 'Error'}: ${causeMessage}`\n          if (causeCode) {\n            errorDetails += ` (${causeCode})`\n          }\n          if (cause?.stack) {\n            errorDetails += `\\n${cause.stack}`\n          }\n        } else {\n          // No cause available, just include the error stack\n          errorDetails = fetchError?.stack ?? ''\n        }\n\n        return {\n          error: {\n            message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n            details: errorDetails,\n            hint: '',\n            code: '',\n          },\n          data: null,\n          count: null,\n          status: 0,\n          statusText: '',\n        }\n      })\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestBuilder<\n    ClientOptions,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    /* istanbul ignore next */\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes<\n    NewResult,\n    Options extends { merge?: boolean } = { merge: true },\n  >(): PostgrestBuilder<\n    ClientOptions,\n    IsValidResultOverride<Result, NewResult, false, false> extends true\n      ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n        ContainsNull<Result> extends true\n        ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n        : MergePartialResult<NewResult, Result, Options>\n      : CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      IsValidResultOverride<Result, NewResult, false, false> extends true\n        ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n          ContainsNull<Result> extends true\n          ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n          : MergePartialResult<NewResult, Result, Options>\n        : CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder, { InvalidMethodError } from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { CheckMatchingArrayTypes } from './types/types'\nimport { ClientServerOptions, GenericSchema } from './types/common/common'\nimport type { MaxAffectedEnabled } from './types/feature-flags'\n\nexport default class PostgrestTransformBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown,\n> extends PostgrestBuilder<ClientOptions, Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<\n    Query extends string = '*',\n    NewResultOne = GetResult<Schema, Row, RelationName, Relationships, Query, ClientOptions>,\n  >(\n    columns?: Query\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    Method extends 'RPC'\n      ? Result extends unknown[]\n        ? NewResultOne[]\n        : NewResultOne\n      : NewResultOne[],\n    RelationName,\n    Relationships,\n    Method\n  > {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    this.headers.append('Prefer', 'return=representation')\n    return this as unknown as PostgrestFilterBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      Method extends 'RPC'\n        ? Result extends unknown[]\n          ? NewResultOne[]\n          : NewResultOne\n        : NewResultOne[],\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n      referencedTable = foreignTable,\n    }: {\n      ascending?: boolean\n      nullsFirst?: boolean\n      foreignTable?: string\n      referencedTable?: string\n    } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(\n    count: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(\n    from: number,\n    to: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const keyOffset =\n      typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never>(): PostgrestBuilder<\n    ClientOptions,\n    ResultOne\n  > {\n    this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never,\n  >(): PostgrestBuilder<ClientOptions, ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers.set('Accept', 'application/json')\n    } else {\n      this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    }\n    this.isMaybeSingle = true\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<ClientOptions, string> {\n    this.headers.set('Accept', 'text/csv')\n    return this as unknown as PostgrestBuilder<ClientOptions, string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<ClientOptions, Record<string, unknown>> {\n    this.headers.set('Accept', 'application/geo+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}) {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers.get('Accept') ?? 'application/json'\n    this.headers.set(\n      'Accept',\n      `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    )\n    if (format === 'json') {\n      return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>[]>\n    } else {\n      return this as unknown as PostgrestBuilder<ClientOptions, string>\n    }\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    this.headers.append('Prefer', 'tx=rollback')\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    RelationName,\n    Relationships,\n    Method\n  > {\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  /**\n   * Set the maximum number of rows that can be affected by the query.\n   * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n   *\n   * @param value - The maximum number of rows that can be affected\n   */\n  maxAffected(value: number): MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n    ? // TODO: update the RPC case to only work on RPC that returns SETOF rows\n      Method extends 'PATCH' | 'DELETE' | 'RPC'\n      ? this\n      : InvalidMethodError<'maxAffected method only available on update or delete'>\n    : InvalidMethodError<'maxAffected method only available on postgrest 13+'> {\n    this.headers.append('Prefer', 'handling=strict')\n    this.headers.append('Prefer', `max-affected=${value}`)\n    return this as unknown as MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n      ? Method extends 'PATCH' | 'DELETE' | 'RPC'\n        ? this\n        : InvalidMethodError<'maxAffected method only available on update or delete'>\n      : InvalidMethodError<'maxAffected method only available on postgrest 13+'>\n  }\n}\n","import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { ClientServerOptions, GenericSchema } from './types/common/common'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'isdistinct'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n  | 'match'\n  | 'imatch'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\nconst PostgrestReservedCharsRegexp = new RegExp('[,()]')\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string,\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n    ? Row[ColumnName]\n    : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n      // the expected type with the parsed custom json type\n      IsStringOperator<ColumnName> extends true\n      ? string\n      : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n        ? JsonPathValue extends never\n          ? never\n          : JsonPathValue\n        : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string,\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport type InvalidMethodError<S extends string> = { Error: S }\n\nexport default class PostgrestFilterBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown,\n> extends PostgrestTransformBuilder<\n  ClientOptions,\n  Schema,\n  Row,\n  Result,\n  RelationName,\n  Relationships,\n  Method\n> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? NonNullable<ResolvedFilterValue>\n        : // We should never enter this case as all the branches are covered above\n          never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  regexMatch<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  regexMatch(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches the PostgreSQL regex `pattern`\n   * case-sensitively (using the `~` operator).\n   *\n   * @param column - The column to filter on\n   * @param pattern - The PostgreSQL regular expression pattern to match with\n   */\n  regexMatch(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `match.${pattern}`)\n    return this\n  }\n\n  regexIMatch<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  regexIMatch(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches the PostgreSQL regex `pattern`\n   * case-insensitively (using the `~*` operator).\n   *\n   * @param column - The column to filter on\n   * @param pattern - The PostgreSQL regular expression pattern to match with\n   */\n  regexIMatch(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `imatch.${pattern}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` IS DISTINCT FROM `value`.\n   *\n   * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n   * are considered equal (not distinct), and comparing `NULL` with any non-NULL\n   * value returns true (distinct).\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  isDistinct<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : never\n  ): this {\n    this.url.searchParams.append(column, `isdistinct.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n          // type resolution error\n          ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n          ? ResolvedFilterValue\n          : // We should never enter this case as all the branches are covered above\n            never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is NOT included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  notIn<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n          ? ResolvedFilterValue\n          : never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `not.in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n","import PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport {\n  ClientServerOptions,\n  Fetch,\n  GenericSchema,\n  GenericTable,\n  GenericView,\n} from './types/common/common'\n\nexport default class PostgrestQueryBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown,\n> {\n  url: URL\n  headers: Headers\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  /**\n   * Creates a query builder scoped to a Postgres table or view.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const query = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: { apikey: 'public-anon-key' } }\n   * )\n   * ```\n   */\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Clone URL and headers to prevent shared state between operations.\n   */\n  private cloneRequestState(): { url: URL; headers: Headers } {\n    return {\n      url: new URL(this.url.toString()),\n      headers: new Headers(this.headers),\n    }\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<\n      Schema,\n      Relation['Row'],\n      RelationName,\n      Relationships,\n      Query,\n      ClientOptions\n    >,\n  >(\n    columns?: Query,\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    ResultOne[],\n    RelationName,\n    Relationships,\n    'GET'\n  > {\n    const { head = false, count } = options ?? {}\n\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n\n    const { url, headers } = this.cloneRequestState()\n    url.searchParams.set('select', cleanedColumns)\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      headers.append('Prefer', `missing=default`)\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   *\n   * @example Upsert a single row using a unique key\n   * ```ts\n   * // Upserting a single row, overwriting based on the 'username' unique column\n   * const { data, error } = await supabase\n   *   .from('users')\n   *   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n   *\n   * // Example response:\n   * // {\n   * //   data: [\n   * //     { id: 4, message: 'bar', username: 'supabot' }\n   * //   ],\n   * //   error: null\n   * // }\n   * ```\n   *\n   * @example Upsert with conflict resolution and exact row counting\n   * ```ts\n   * // Upserting and returning exact count\n   * const { data, error, count } = await supabase\n   *   .from('users')\n   *   .upsert(\n   *     {\n   *       id: 3,\n   *       message: 'foo',\n   *       username: 'supabot'\n   *     },\n   *     {\n   *       onConflict: 'username',\n   *       count: 'exact'\n   *     }\n   *   )\n   *\n   * // Example response:\n   * // {\n   * //   data: [\n   * //     {\n   * //       id: 42,\n   * //       handle: \"saoirse\",\n   * //       display_name: \"Saoirse\"\n   * //     }\n   * //   ],\n   * //   count: 1,\n   * //   error: null\n   * // }\n   * ```\n   */\n\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n    const { url, headers } = this.cloneRequestState()\n\n    headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`)\n\n    if (onConflict !== undefined) url.searchParams.set('on_conflict', onConflict)\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      headers.append('Prefer', 'missing=default')\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'PATCH'\n  > {\n    const method = 'PATCH'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'DELETE'\n  > {\n    const method = 'DELETE'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n","import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { Fetch, GenericSchema, ClientServerOptions } from './types/common/common'\nimport { GetRpcFunctionFilterBuilderByArgs } from './types/common/rpc'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  ClientOptions extends ClientServerOptions = Database extends {\n    __InternalSupabase: infer I extends ClientServerOptions\n  }\n    ? I\n    : {},\n  SchemaName extends string &\n    keyof Omit<Database, '__InternalSupabase'> = 'public' extends keyof Omit<\n    Database,\n    '__InternalSupabase'\n  >\n    ? 'public'\n    : string & keyof Omit<Database, '__InternalSupabase'>,\n  Schema extends GenericSchema = Omit<\n    Database,\n    '__InternalSupabase'\n  >[SchemaName] extends GenericSchema\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\n    : any,\n> {\n  url: string\n  headers: Headers\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   * @example\n   * ```ts\n   * import PostgrestClient from '@supabase/postgrest-js'\n   *\n   * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n   *   headers: { apikey: 'public-anon-key' },\n   *   schema: 'public',\n   * })\n   * ```\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName],\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any, any> {\n    if (!relation || typeof relation !== 'string' || relation.trim() === '') {\n      throw new Error('Invalid relation name: relation must be a non-empty string.')\n    }\n\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder(url, {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    ClientOptions,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @example\n   * ```ts\n   * // For cross-schema functions where type inference fails, use overrideTypes:\n   * const { data } = await supabase\n   *   .schema('schema_b')\n   *   .rpc('function_a', {})\n   *   .overrideTypes<{ id: string; user_id: string }[]>()\n   * ```\n   */\n  rpc<\n    FnName extends string & keyof Schema['Functions'],\n    Args extends Schema['Functions'][FnName]['Args'] = never,\n    FilterBuilder extends GetRpcFunctionFilterBuilderByArgs<\n      Schema,\n      FnName,\n      Args\n    > = GetRpcFunctionFilterBuilderByArgs<Schema, FnName, Args>,\n  >(\n    fn: FnName,\n    args: Args = {} as Args,\n    {\n      head = false,\n      get = false,\n      count,\n    }: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    FilterBuilder['Row'],\n    FilterBuilder['Result'],\n    FilterBuilder['RelationName'],\n    FilterBuilder['Relationships'],\n    'RPC'\n  > {\n    let method: 'HEAD' | 'GET' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    // objects/arrays-of-objects can't be serialized to URL params, use POST + return=minimal instead\n    const _isObject = (v: unknown): boolean =>\n      v !== null && typeof v === 'object' && (!Array.isArray(v) || v.some(_isObject))\n    const _hasObjectArg = head && Object.values(args as object).some(_isObject)\n    if (_hasObjectArg) {\n      method = 'POST'\n      body = args\n    } else if (head || get) {\n      method = head ? 'HEAD' : 'GET'\n      Object.entries(args)\n        // params with undefined value needs to be filtered out, otherwise it'll\n        // show up as `?param=undefined`\n        .filter(([_, value]) => value !== undefined)\n        // array values need special syntax\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n        .forEach(([name, value]) => {\n          url.searchParams.append(name, value)\n        })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = new Headers(this.headers)\n    if (_hasObjectArg) {\n      headers.set('Prefer', count ? `count=${count},return=minimal` : 'return=minimal')\n    } else if (count) {\n      headers.set('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n","import PostgrestClient from './PostgrestClient'\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestError from './PostgrestError'\n\nexport {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport type {\n  PostgrestResponse,\n  PostgrestResponseFailure,\n  PostgrestResponseSuccess,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n} from './types/types'\nexport type { ClientServerOptions as PostgrestClientOptions } from './types/common/common'\n// https://github.com/supabase/postgrest-js/issues/551\n// To be replaced with a helper type that only uses public types\nexport type { GetResult as UnstableGetResult } from './select-query-parser/result'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}